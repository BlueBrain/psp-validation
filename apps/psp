#!/usr/bin/env python
# -*- coding: utf-8 -*-

#pylint: skip-file

from __future__ import print_function

import os
import yaml
import logging

import click
import h5py
import numpy as np

import bluepy

from psp_validation import psp
from psp_validation.pathways import get_pairs, get_synapse_type
from psp_validation.persistencyutils import dump_pair_traces
from psp_validation.version import VERSION


LOGGER = logging.getLogger(__name__)


def load_yaml(filepath):
    """ Load YAML file. """
    with open(filepath, 'r') as f:
        return yaml.load(f)


def load_config(filepath):
    """ Load YAML job config. """
    title = os.path.splitext(os.path.basename(filepath))[0]
    return title, load_yaml(filepath)


def get_traces(blue_config, pre_gid, post_gid, protocol, n_repetitions, seed, jobs):
    from psp_validation.psp import run_pair_trace_simulations

    hold_V = protocol['hold_V']
    if hold_V is None:
        hold_I = None
    else:
        from bglibpy import holding_current
        LOGGER.info("Calculating a%d holding current", post_gid)
        hold_I, _ = holding_current(hold_V, post_gid, blue_config)

    LOGGER.info("Running simulation(s) for a%d -> a%d pair (base_seed=%d)", pre_gid, post_gid, seed)
    return run_pair_trace_simulations(
        blue_config=blue_config,
        pre_gid=pre_gid,
        post_gid=post_gid,
        hold_I=hold_I,
        hold_V=hold_V,
        t_stim=protocol['t_stim'],
        t_stop=protocol['t_stop'],
        g_factor=1.0,
        record_dt=protocol['record_dt'],
        post_ttx=protocol['post_ttx'],
        v_clamp=protocol['v_clamp'],
        spikes=None,
        repetitions=n_repetitions,
        rndm_seed=seed,
        jobs=jobs
    )


@click.group()
@click.version_option(version=VERSION)
@click.option("-v", "--verbose", count=True, help="-v for INFO, -vv for DEBUG")
def app(verbose=0):
    """ PSP analysis tool """
    logging.basicConfig(level=logging.WARNING)
    LOGGER.setLevel({
        0: logging.WARNING,
        1: logging.INFO,
        2: logging.DEBUG
    }[verbose])


@app.command()
@click.argument("pathway_files", nargs=-1)
@click.option("-c", "--blueconfig", required=True, help="Path to BlueConfig")
@click.option("-t", "--targets", required=True, help="Path to neuron groups definitions (YAML)")
@click.option("-o", "--output-dir", required=True, help="Path to output folder")
@click.option(
    "-n", "--num-pairs", type=int, required=True, help="Sample NUM_PAIRS pairs from each pathway"
)
@click.option(
    "-r", "--num-trials", type=int, required=True, help="Run NUM_TRIALS simulations for each pair"
)
@click.option("--dump-traces", is_flag=True, help="Dump PSP traces", show_default=True)
@click.option("--dump-amplitudes", is_flag=True, help="Dump PSP amplitudes", show_default=True)
@click.option("--seed", type=int, help="Pseudo-random generator seed")
@click.option("-j", "--jobs", type=int, help=(
        "Number of trials to run in parallel"
        "(if not specified, trials are run sequentially; "
        "setting to 0 would use all available CPUs)"
    )
)
def run(
    pathway_files, blueconfig, targets, output_dir, num_pairs, num_trials,
    dump_traces=False, dump_amplitudes=False, seed=None, jobs=None
):
    """ Obtain PSP amplitudes; derive scaling factors """
    if seed is None:
        seed = np.random.randint(1e9)
    np.random.seed(seed)

    circuit = bluepy.Circuit(blueconfig).v2
    targets = load_yaml(targets)

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for config_path in pathway_files:
        title, config = load_config(config_path)
        LOGGER.info("Processing '%s' pathway...", title)

        pathway = config['pathway']
        if isinstance(pathway, list):
            for item in pathway:
                assert isinstance(item, list) and len(item) == 2
            pairs = pathway
        else:
            LOGGER.info("Querying pathway pairs...")
            pre = targets[pathway['pre']]
            post = targets[pathway['post']]
            pairs = get_pairs(
                circuit, pre, post, num_pairs, constraints=pathway.get('constraints')
            )

        pre_syn_type = get_synapse_type(circuit, [p[0] for p in pairs])

        protocol = config['protocol']

        t_stim = config['protocol']['t_stim']
        t_start = t_stim - 10.
        spike_filter = psp.default_spike_filter(t_start)

        if dump_traces:
            traces_path = os.path.join(output_dir, title + ".traces.h5")
            with h5py.File(traces_path, 'w') as h5f:
                # create empty H5 dump or overwrite existing one
                pass

        all_traces = []
        all_amplitudes = []
        for pre_gid, post_gid in pairs:
            traces = get_traces(
                blueconfig, pre_gid, post_gid, protocol, num_trials, seed=seed, jobs=jobs
            )
            trials = np.array([tr[:2] for tr in traces])
            v_mean, t, _, _ = psp.mean_pair_voltage_from_traces(trials, spike_filter)
            if v_mean is None:
                LOGGER.warning(
                    "All traces filtered out for a%d-a%d simulation(s)", pre_gid, post_gid
                )
                average = None
                ampl = np.nan
            else:
                average = np.stack([v_mean, t])
                ampl = psp.get_peak_amplitude(t, v_mean, t_start, t_stim, pre_syn_type)
            all_amplitudes.append(ampl)
            if dump_traces:
                with h5py.File(traces_path, 'a') as h5f:
                    dump_pair_traces(h5f, trials, average, pre_gid, post_gid)
                all_traces.append(traces)

        if dump_amplitudes:
            amplitudes_path = os.path.join(output_dir, title + ".amplitudes.txt")
            np.savetxt(amplitudes_path, all_amplitudes, fmt="%.9f")

        model_mean = np.nanmean(all_amplitudes)
        model_std = np.nanstd(all_amplitudes)

        if 'reference' in config:
            reference = config['reference']['psp_amplitude']
            v_holding = config['protocol']['hold_V']
            scaling = psp.compute_scaling(model_mean, reference['mean'], v_holding, pre_syn_type)
        else:
            reference = {'mean': None, 'std': None}
            scaling = None

        summary_path = os.path.join(output_dir, title + ".summary.yaml")
        with open(summary_path, 'w') as f:
            print(
                "pathway: {pathway}\n"
                "model:\n"
                "    mean: {model_mean}\n"
                "    std:  {model_std}\n"
                "reference:\n"
                "    mean: {ref_mean}\n"
                "    std:  {ref_std}\n"
                "scaling: {scaling}".format(
                    pathway=title,
                    model_mean=model_mean,
                    model_std=model_std,
                    ref_mean=reference['mean'],
                    ref_std=reference['std'],
                    scaling=scaling
                ),
                file=f
            )


@app.command()
@click.argument("summary_files", nargs=-1)
@click.option("-s", "--style", type=click.Choice(['default', 'jira']), help="Table style")
@click.option("--with-scaling", is_flag=True, help="Include 'scaling' column")
def summary(summary_files, with_scaling=False, style='default'):
    """ Print table with `psp run` output summary """
    def _format_value(value):
        if value is None:
            return "N/A"
        else:
            return "%.6g" % value

    def _format_value_mean_std(value):
        if value is None:
            return "N/A"
        else:
            return "%.6gÂ±%.6g" % (value['mean'], value['std'])

    def _add_borders(values):
        return [''] + values + ['']

    headers = ['pathway', 'reference', 'model']
    if with_scaling:
        headers.append('scaling')
    if style == 'jira':
        print(*_add_borders(headers), sep="||")
    else:
        print(*headers, sep="\t")

    for filepath in summary_files:
        data = load_yaml(filepath)
        row = [
            data['pathway'],
            _format_value_mean_std(data.get('reference')),
            _format_value_mean_std(data.get('model'))
        ]
        if with_scaling:
            row.append(
                _format_value(data.get('scaling'))
            )
        if style == 'jira':
            print(*_add_borders(row), sep="|")
        else:
            print(*row, sep="\t")


@app.command()
@click.argument("traces_files", nargs=-1)
@click.option("-o", "--output-dir", required=True, help="Path to output folder")
def plot(traces_files, output_dir):
    """ Plot voltage traces stored in .h5 dump """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    from tqdm import tqdm

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for filepath in traces_files:
        pathway = os.path.basename(filepath).split(".", 1)[0]
        pathway_output_dir = os.path.join(output_dir, pathway)
        if not os.path.exists(pathway_output_dir):
            os.makedirs(pathway_output_dir)

        with h5py.File(filepath, 'r') as h5f:
            if len(h5f) != 1:
                raise RuntimeError("Unexpected HDF5 layout")
            root = next(h5f.itervalues())
            if root.name != "/traces":
                raise RuntimeError("Unexpected HDF5 layout")
            for pair in tqdm(root.itervalues(), total=len(root), desc=pathway):
                title = "a{pre}-a{post}".format(
                    pre=pair.attrs['pre_gid'], post=pair.attrs['post_gid']
                )
                figure = plt.figure()
                ax = figure.gca()
                for k, trial in enumerate(pair['trials']):
                    label = 'trials' if (k == 0) else None  # show 'trials' only once in the legend
                    v_k, t_k = trial
                    ax.plot(t_k, v_k, color='gray', lw=1, ls=':', alpha=0.7, label=label)
                if 'average' in pair:
                    v_avg, t_avg = pair['average']
                    ax.plot(t_avg, v_avg, lw=2, label="average")
                ax.grid()
                ax.set_xlabel('t [ms]')
                ax.set_ylabel('V [mV]')
                ax.legend()
                ax.set_title(title)
                figure.savefig(os.path.join(pathway_output_dir, title + ".png"), dpi=300)
                plt.close(figure)


if __name__ == "__main__":
    app()
